# 基础组件
半加器：不考虑低位进位输入，仅考虑一位加法的本位和和高位输出。$F=A+B, Cout=A \cdot B$
全加器：考虑低位进位输入。化简可得$F=A\oplus B\oplus Cin, Cout=A \cdot B+A\cdot Cin+B\cdot Cin$。
## 串行进位加法器（行波进位加法器）
### 逻辑和结构
全加器串连，逐位相加。
- 优点：实现结构简单
- 缺点：计算速度慢，计算耗时与计算位数成正比！
### 电路定时分析：分析组合逻辑电路的**传输延迟**
- 从A,B,Cin到Cout：与、或各一级延迟，1+1=2（**默认考虑与或非门的级数**）
- 从A,B,Cin到F：两级异或门延迟，3+3=6
  >估算时一般认为异或门的传输延迟为与、或门约3倍：$A\oplus B=A\bar B+\bar{A}B$，与、或、非各为1级。
  >	虽然三输入异或门可以化简为$A \bar{B}\bar{C}+\bar{A}B \bar{C}+\bar{A}\bar{B}C+ABC$，如果这样的话用三输入与门可以减少到3级与或非门延迟，但一般实现用**两个二输入异或门级联**。
- 从C0到Cn：经过$2*n=2n$的延迟
- $F_{n-1}$（最后一位和数）的延迟：$F_{n-1}=(A_{n-1}\oplus B_{n-1})\oplus C_{n-1}$，$C_{n-1}$的计算从$C_{0}$和所有的$A_{i},B_{i}$都准备好开始共经过$2*(n-1)=2n-2$级门延迟，此延迟期间$A_{n-1}\oplus B_{n-1}$早已计算好，因此$F_{n-1}$只需再经一级异或门（3级与或非门延迟），总时长为$2n-2+3=2n+1$级门延迟。

## 并行进位加法器（先行进位加法器/CLA加法器）
### 逻辑和结构
Carry Look Ahead
定义辅助函数：
- $G_{i}=A_{i}B_{i}$进位生成函数（Generation）
- $P_{i}=A_{i}+B_{i}$进位传递函数（Propagation）
全加逻辑方程：
$F_{i}=A_{i}\oplus B_{i}\oplus C_{i}$，$C_{i}=A_{i-1}B_{i-1}+A_{i-1}C_{i-1}+B_{i-1}C_{i-1}=G_{i-1}+P_{i-1}C_{i-1}(i\geq 1)$。
因此用全加逻辑方程中的进位方程来展开各位进位的表达式：
$C_{1}=G_{0}+P_{0}C_{0}$
$C_{2}=G_{1}+P_{1}G_{0}+P_{1}P_{0}C_{0}$
$C_{3}=G_{2}+P_{2}G_{1}+P_{2}P_{1}G_{0}+P_{2}P_{1}P_{0}C_{0}$。
$C_{4}=G_{3}+P_{3}G_{2}+P_{3}P_{2}G_{1}+P_{3}P_{2}P_{1}G_{0}+P_{3}P_{2}P_{1}P_{0}C_{0}$
其中$C_{i}$是进到第$i$位的进位值。
理解：**$G_{i}=1$表示第$i$位向高位产生进位，无论$C_{i}$的值如何；$P_{i}=1$表示进入第$i$位的进位值能传递到第$i+1$位。**
因此$C_{i}$的表达式列举了$C_{i}$从第$0,1,\dots,i-1$位取得进位的所有可能。
以上是**4位CLA加法器**。

4位先行进位部件（CLU）结构：
![[Pasted image 20240625101655.png]]
4位先行进位加法器结构：
![[Pasted image 20240625101727.png]]

信息流向：$X_{0:n-1},Y_{0:n-1}\to G_{0:n-1},P_{0:n-1}\to C_{1:n}\to F_{0:n-1}$
### 电路定时分析
$P_{i},G_{i}$一级门延迟，再经$C_{i}$计算与、或各一级门延迟。只要**3级门延迟**就能实现全部进位的计算。因为$A_{i}\oplus B_{i}$也是3级门延迟，$F_{i}$的计算只需在此之上加多一级异或（3级门延迟）就完成。**共6级门延迟**。

## 局部（单级）先行进位加法器
原因：虽然完全并行进位加法器能控制计算耗时为常数级，但代价是**逻辑方程长度与计算位数成正比**。
权衡方法：用多个完全先行进位加法器串联。
### 结构和定时分析
==组内并行、组间串行==

![[Pasted image 20240625102620.png]]

问：**所有和数产生**的延迟是多少？
先看单个8位CLA加法器：从所有A,B（0~31位）计算所有G,P需要1级，+C1~C8计算2级。**C8计算完后C9~C16才能计算**，也需要2级，依此类推。因此C1~C32全部算完共需2+2+2+2=8级。因为此期间所有$A_{i}\oplus B_{i}$都已算好，只需再经1级异或门即3级门延迟即可得到所有和数（制约瓶颈主要是Result[31:24]的那部分和数计算）。
**共计1+8+3=12级门延迟**。

## 多级（两级）先行进位加法器
==组内并行、组间并行==

用BCLU（Block Carry Look-ahead Unit，成组先行进位部件/BCLA部件）来实现组间并行：



![[Pasted image 20240625105356.png]]
最低的4位加法器中根据前面的分析$C_{4}=G_{3}+P_{3}G_{2}+P_{3}P_{2}G_{1}+P_{3}P_{2}P_{1}G_{0}+P_{3}P_{2}P_{1}P_{0}C_{0}$，令$G_{m 0}=G_{3}+P_{3}G_{2}+P_{3}P_{2}G_{1}+P_{3}P_{2}P_{1}G_{0}, P_{m 0}=P_{3}P_{2}P_{1}P_{0}$，（分别为**组间进位生成函数和传递函数/**）
可写为$C_{4}=G_{m 0}+P_{m 0}C_{0}$。
同理可以定义$G_{m1},P_{m1},\dots,G_{m3},P_{m3}$，有$C_{8}=G_{m1}+P_{m1}C_{4}$，$C_{12}=G_{m{2}}+P_{m2}C_{8}$，$C_{16}=G_{m3}+P_{m3}C_{12}$。
展开得到：
$C_{4}=G_{m 0}+P_{m 0}C_{0}$
$C_{8}=G_{m 1}+P_{m 1}G_{m 0}+P_{m 1}P_{m 0}C_{0}$
$C_{12}=G_{m2}+P_{m 2}G_{m 1}+P_{m 2}P_{m 1}G_{m 0}+P_{m 2}P_{m 1}P_{m 0}C_{0}$
$C_{16}=G_{m3}+P_{m 3}G_{m 2}+P_{m 3}P_{m 2}G_{m 1}+P_{m 3}P_{m 2}P_{m 1}G_{m 0}+P_{m 3}P_{m 2}P_{m 1}P_{m 0}C_{0}$
==并行地从所有A,B和最低进位C0计算各组间进位==。
### 定时分析
$A_{0:31},B_{0:31}\to G_{0:31},P_{0:31}$：1级 计算==组内进位生成/传递函数==
$\to G_{m0\sim m3}$：2级（与-或表达式，与门、或门各一级） 计算==组间进位生成/传递函数==
$\to C_{4},C_{8},C_{12},C_{16}$：2级（与门、或门各一级），即在BCLU中完成组件进位计算 计算==组间进位==
$\to C_{5:7,9:11,13:15}$：2级（用$G_{i},P_{i}$和$C_{4},C_{8},C_{12}$来计算，与门、或门各一级） 计算==组内进位==
$\to F_{5:7,9:11,13:15}$：3级（$A_{i}\oplus B_{i}$早已全部算好，待组内进位完成计算后再过一级异或门） 计算==和数==

- 传输延迟（所有部分完成计算）：**1+2+2+2+3=10级门延迟**，是不依赖于CLA加法器个数的常数。
- 组间进位延迟：1+2+2=5级门延迟，就已经完成组间进位的计算

p.s. 由于$C_{1:3}$不需要计算组间进位G/P，在组内进位G/P计算后就很快生成，然后$F_{0:3}$也很快算完；$F_{4,8,12}$在组间进位G/P计算后也很快算完。因此上面只分析拖后腿的部分。
### 更多级先行进位加法器
示例图片：
![[Pasted image 20240625105246.png]]


## n位带标志加法器

基于多级CLA加法器实现。

标志位原理见手动分析。
- $OF=C_{n}\oplus C_{n-1}$：==溢出标志，判断**带符号**加法是否溢出==。
  >另表达式：次高、最高位进位不同之外的另一种判断方式：如果加数符号相反，则肯定不会溢出；如果加数符号相同，而**和与两加数符号相反，则一定发生了溢出**。因此有
  >$OF=A_{n-1}B_{n-1} \bar{F}_{n-1}+\bar{A}_{n-1}\bar{B}_{n-1}F_{n-1}$。该表达式更加直观。
- $SF=F_{n-1}$：符号标志
- $ZF=\bar{F}_{n-1}\cdot\bar{F}_{n-2}\cdot\dots \cdot\bar{F}_{0}=\overline{F_{n-1}+\dots+F_{0}}$：零标志，当且仅当所有位为零时为1，其他时候为0
- $CF=C_{n}\oplus C_{0}$：==进位/借位标志，判断**无符号**数加/减法是否出现溢出或不够减。==
> 无符号数加法时相当于正数原码A+B，$C_{0}$置为$0$。此时若$C_{n}=1$说明溢出。
> 无符号数减法时仍然是在补码表示下运算。为了实现对B的取反+1，$C_{0}$置为1，并且对$B$按位取反后再输入。设$A,B$的真值分别为$a,b(0\leq a,b\leq 2^n-1)$，则$-b$的补码是二进制数$2^{n}-b$，若$C_{n}=0$，说明$a+(2^{n}-b)\geq 2^n$即$a\geq b$，够减；反之$C_{n}=1$则$a<b$，说明不够减。


## ALU 算术逻辑部件
在带标志加法器基础上，附加其他按位逻辑运算、移位运算等。带有操作选择位输入。

>p.s. 算术移位和逻辑移位的区别：逻辑移位把n位二进制当成位串（无符号整数）。即：逻辑左移弃去最高位，低位补0；逻辑右移弃去最低位，高位补0.
>**算术移位只对n低n-1位进行，而不影响最高位——标志位**。？？？？？？？？？？？不对？？？

算术移位的标准定义：
- 算术左移：弃去最高位，低位补0
- 算术右移：弃去最低位，高位补原先的最高位（符号位）

符号扩展、零扩展规则类似。

# 运算方法
## 原码加减法
原码加减法应用于浮点数尾数（定点小数）的运算。
==注意：定点小数写成(1.xxxx)的原码形式，小数点前面是符号位，不是真实的数值位！==

- 加法：$A,B$的符号若相同，绝对值求和即可
- 否则应求差，即求$[-B]_{补}$，后与$A$数值位相加
	- 若结果为正，则$|A|\geq|B|$，符号与$A$一致，结束
	- 否则结果为负，应取反+1得到其绝对值，且结果符号与$B$一致
- 减法：$A,B$符号若相反，绝对值求和即可，符号与$A$一致
- 否则$A,B$符号相同，应求差，求$[-B]_{补}$与$A$数值位相加
	- 若结果为正，则$|A|\geq|B|$，符号与$A$一致，结束
	- 否则结果为负，应取反+1得到其绝对值，且结果符号与$A$相反

==**结果的正负判定依据：最高数值位是否产生进位，若产生则为正，否则为负。**==
原理：求差执行的是$a+(-b)$，其中$a=|A|$总是正数，$-b=-|B|$总是负数。如果用扩增一位的补码来表示，例如$A$的原码是$1.0011$，$B$的原码是$1.1010$，做减法应当同号求差，$B:01010\to 10110$为$-|B|$的补码形式，$A:00011$为$|A|$，相加得$11001$，最高位为$1$表明为负数，此时得到的是$|A|-|B|$的补码形式。其实不需要最高位，若相加最高位不产生进位，则补码额外一位一定为1，反之一定为0.


## 移码加减法
n位移码，按照$[A]_{移}=A+2^{n-1}$来定义，则与补码正好只是最高位相反。
$[A]_{移}+[B]_{移}\equiv A+B+2^n\equiv[A+B]_{补}(\mod 2^n)$
$[A]_{移}-[B]_{移}\equiv A-B\equiv A-B+2^n\equiv[A-B]_{补}(\mod 2^n)$
这是因为$[A]_{补}$的定义就是$(A+2^n)\mod 2^n$

因此，移码加、减法得到结果的补码，需要取反符号位转换为移码。溢出判断：若$A,B$符号位不同则不会溢出；若符号位相同，且**得到的结果（为补码）与$A,B$的符号位也相同**，则说明**计算结果的移码与原先两数移码的符号位相反**，发生了溢出。

## ！原码乘法
原码乘法主要用于无符号整数、定点小数（如浮点数小数运算）。
==要熟悉计算机内不断右移部分积的乘积计算方式。==

原码乘法中小数点位置只是约定，约定在最右则表示定点正数乘法，约定在最左则表示定点小数乘法，并无实际意义。

### 一位原码乘法
规范的手算模拟格式：注明进位寄存器C、乘积寄存器P和乘数寄存器R，加法、移位操作注明+、→。最好把部分积和乘数的界限分清楚！
![[Pasted image 20240625153848.png]]
一位原码乘法递推公式：
$P_{i+1}=2^{-1}(P_{i}+X\cdot Y_{i}),P_{0}=0$。其中$2^{-1}$仅代表位移操作，为方便表示将$X,Y$约定为$n$位小数，$P_{i}$为$n+i$位小数。乘法总循环次数为$n$。

### 两位原码乘法
递推公式：假设$n$为偶数。讨论$Y_{i+1}Y_{i}$两位的取值情况。
- $Y_{i+1}Y_{i}=00$：$P_{i+2}=2^{-2}P_{i}$
- $Y_{i+1}Y_{i}=01$：$P_{i+2}=2^{-2}(P_{i}+X)$
- $Y_{i+1}Y_{i}=10$：$P_{i+2}=2^{-2}(P_{i}+2X)$，通过将$X$左移一位提前准备好$2X$。
- $Y_{i+1}Y_{i}=11$：$P_{i+2}=2^{-2}(P_{i}+3X)=2^{-2}(P_{i}+4X-X)=2^{-2}(P_{i}-X)+X$，通过ALU设置Sub=1执行减法来在本次迭代中加上$-X$，而需要用纠偏标志寄存器$T$来记录下次是否需要额外$+X$。
	- 实际执行时需要按当前$T$的标志决定真正加上多少倍$X$，并且更新$T$。
	- 最后一次迭代后如果$T\neq 0$，需要额外完成$+X$操作进行纠偏。
![[Pasted image 20240625155955.png]]

加法位数需求：$X$为$n$位数，$P_{i}$总是高$n$位参与运算。由于可能还要做$-X$减法，实际上是把$P_{i}$和$kX$（$k=-1,0,1,2$）都看成补码参与运算。$2X\leq 2^{n+1}-1,-X\geq-(2^n-1)$，$P_{i}$的高$n$位$-2^n\le P\leq 2^n-1$，则执行加法之后结果范围是$-2^{n+1}+1\leq A\leq 2^{n+1}+2^n-2$，**因为$k$位补码的表示范围是$-2^{k-1}\leq A\leq 2^{k-1}-1$，因此至少要取$k=n+3$才能覆盖**所有可能情况。所以==运算前要先将$X$符号扩展成$n+3$位（模8补码）。==，之后$+kX$的操作都是用模8补码计算。

==最终溢出判断==：$0\leq X,Y\leq 2^n-1$，则$0\leq X,Y\leq 2^{2n}-2^{n+1}+1$，因此$2n$位可以保证不会溢出；如果==只保留低$n$位，则需要高$n$位全0才不会溢出，否则存在溢出问题==。

## ！补码乘法
### 一位补码乘法：Booth算法
推导：
设n位机器数$X=X_{n-1}X_{n-2}\dots X_{0},Y=Y_{n-1}Y_{n-2}\dots Y_{0}$为$x,y$的补码表示。则真值$y$的表达式：$Y_{n-1}=0$时$y=-0\cdot 2^{n-1}+Y_{n-2}\cdot 2^{n-2}+\dots+Y_{0}\cdot 2^0$。$Y_{n-1}=1$时$y<0,Y=2^n-|y|$，从而$y=-(2^n-Y)=-2\cdot 2^{n-1}+1\cdot2^{n-1}+Y_{n-2}\cdot 2^{n-2}+\dots+Y_{0}\cdot 2^0=-1\cdot 2^{n-1}+Y_{n-2}\cdot 2^{n-2}+\dots+Y_{0}\cdot2^0$。
**综上总有**$y=-Y_{n-1}\cdot 2^{n-1}+Y_{n-2} \cdot 2^{n-2}+\dots+Y_{0} \cdot 2^0$。

则$$
\begin{align}
y&=-Y_{n-1}2^{n-1}+Y_{n-2}(2^{n-1}-2^{n-2})+\dots+Y_{0}(2^1-2^0)\\
&=(Y_{n-2}-Y_{n-1})2^{n-1}+(Y_{n-3}-Y_{n-2})2^{n-2}+\dots+(Y_{-1}-Y_{0})2^0 \\
&=\sum_{i=0}^{n-1}(Y_{i-1}-Y_{i})2^i
\end{align}

$$
其中$Y_{-1}=0$。

加法位数需求：公式中包括$[P_{i}+kx]_{补}(k=-1,0,1)$的情况，设$P_{i}$的高$n$位为$P$，$-2^{n-1}\leq P,kx\leq 2^{n-1}-1$，则$-2^n\leq P+kx\leq 2^n-2$，==至少要用$n+1$位表示才能保证不溢出，因此需要在左侧额外补一位，即扩展1个符号位（成为模4补码）==。

因为不存在$+3x$的情况，最后不存在额外纠偏操作。
### 两位补码乘法

加法位数需求：$k=-2,-1,0,1,2$，用与上面类似的方法可知至少要用$n+2$位表示才能保证不溢出，因此需要==扩展2个符号位（成为模8补码）==。


补码乘法的==最终溢出判断==：最得到2n位乘积补码可以保证一定不溢出；如果==**只保留低n位，则当且仅当高n位全都与低n位的符号位（即第n-1位）相同时才不溢出**==（也就相当于：从模较大的补码到模较小的补码的转换未造成数据损失）。

计算机内**乘法符号错误、溢出可能性比较**：
- 浮点数乘法：可能上溢（绝对值过大）或下溢（绝对值过小），但符号一定正确，因为符号是单独处理的
- 带符号整数：可能溢出，且可能存在$x^2<0$的情况，原因在于执行的是$n$位补码乘法，得到的2n位乘积若舍去高n位，可能导致低n位的符号位不等于真正的符号位。
- 无符号整数：可能溢出，乘积无论是否正确仍然解读为无符号数。

总结：原码一位乘法、补码一位乘法都需要1位扩展，**原码两位乘法需要3位扩展**、补码两位乘法需要2位扩展，更多位乘法应该类似。其中**原码乘法都是零扩展（相当于预留进位空间），补码乘法都是符号扩展**。原码乘法右移是逻辑移位（高位补0），补码乘法右移是算术移位（高位补符号位）。


## 原码/补码乘法方法总结

总结要素如下：注意**部分积和X（及其倍数kX）的原码/补码的扩展始终是符号扩展**，只不过在原码一位乘法中表现得和零扩展没有区别。

| 算法           | 部分积和X的扩展位数 | +kX         | $X,Y,P_i$参与运算的位 | 右辅助位                   |
| ------------ | ---------- | ----------- | --------------- | ---------------------- |
| 原码一位乘法       | 左1位：用于进位保存 | 0,1         | 数值位：原码符号位单独处理   | 无                      |
| 原码两位乘法       | 左3位（模8补码）  | -1,0,1,2    | 数值位             | 1位$T$（记录<br>下次是否额外+1X） |
| 布斯一位乘法       | 左1位        | -1,0,1      | 所有位             | 1位$Y_{-1}$             |
| MBA(Radix-4) | 左2位        | -2,-1,0,1,2 | 所有位             | 1位$Y_{-1}$             |
- **本次执行的操作如何决定**：原码两位乘法由$Y_{i+1},Y_{i},T$共同决定；一位Booth乘法由$Y_{i},Y_{i-1}$共同决定；两位Booth乘法由$Y_{i+1},Y_{i},Y_{i-1}$共同决定。
- 现推方法：根据迭代方程和Booth算法的推导过程（对$Y$的变形操作）来推导。一位Booth乘法的特征是$k=Y_{i-1}-Y_{i}$，两位Booth乘法的特征是$k=Y_{i-1}+Y_{i}-2Y_{i+1}$，原码两位乘法因为涉及当前$T$的取值的具体考量要更复杂一些，最好现推。
- 原码两位乘法的原始迭代方程：$P_{i+2}=2^{-2}(P_{i}+(Y_{i}+2Y_{i+1})X)$。


## 原码除法
只需考虑无符号（定点）数除法。$X/Y$，其中$X,Y$均为$n$位，需要将$X$扩展成$2n$位，以便配合余数寄存器R和余数/商寄存器Q的硬件设计。
- 两个n位定点整数相除：被除数高n位填充0。余数、商一定不超过n位，不会发生溢出。
- 两个n位定点小数相除：被除数低n位填充0。
- 2n位数除以n位数：产生的商可能不止n位（如：2n位整数除以n位最多可得n+1位整数）

## ！浮点数运算
只需掌握IEEE754标准浮点数的加减法。

通用的计算一般只用于非零规格化数之间，特殊数（正负零、正负无穷大、NaN）参与四则运算时通过预处理判断就可以得到结果。非规格化数参与运算可能也要进行对接操作。



- 对阶：小阶向大阶看齐。$[\Delta E]_{补}=[E_{x}]_{移}+[-E_{y}]_{移}$，若非负则$E_{x}$更大，否则$E_{y}$更大。将阶较小的数的尾数部分右移$|\Delta E|$位，使得两数的阶变得相等相等。需要==注意不要漏了把$2^0$的隐藏位提出来！==
  >可能存在溢出情况：如IEEE754单精度浮点数：符号1位，阶码8位，尾数23位，则bias=127，$-127<E_{x},E_{y}<128$为规格化数阶的范围，$-255<E_{x}-E_{y}<255$，而8位补码表示范围是$[-128,127]$，因此有较大可能溢出。
  >
  

### 浮点数运算操作流程
这里的操作流程只针对IEEE754标准。

1. 对阶
	1. 阶码（用移码表示的阶）作差比较大小：$[\Delta E]_{补}=[E_{x}]_{移}-[E_{y}]_{移}=[E_{x}]_{移}+[-[E_{y}]_{移}]_{补}$，即将被减的阶码取反+1之后相加。看$[\Delta E]_{补}$符号位，若为0则$y$需要对阶，否则$x$需要对阶.
	2. 假设$y$阶码较小，其原先的形式为$E_{y}|(1).bbbbbbbb\dots$，对阶操作为$E_{y}\gets E_{y}+\Delta E$，尾数后移得到$(0).00\dots 00bbbbbb\dots bb|bbb$，其中最后三位分别为保护位（警戒位）、舍入位和粘位，粘位的舍入规则是被舍弃的位只要不全为0粘位就为1，否则粘位为0.
	   （如果小数后面一长串本来就是0，则手算时不用考虑三个附加位）
	
2. 尾数加减
   **就是原码加减法**：阶较大的x的形式为$(1).bbbbb\dots$，阶较小的$y$的形式为$(0).0\dots 0bbb\dots$（这里只写绝对值形式）。若做加法：同号则做和，直接相加即可。异号则作差，需要将$y$取反+1（==包括小数点前面的隐藏位==）得到补码，再加到$x$的原码上，**如果小数点前1位向高位产生了进位（该进位不计入结果）则说明减法正常**，得到的就是**差的原码形式**，差的符号与被减数一致；否则得到的是**差的补码形式**，要将差取反+1得到原码，差的符号与减数一致。若做减法：同号求差，异号求和，方法同上。
3. 尾数**规格化**
	1. 需要左规的形式：$(0).0\dots 0bbbbbb\dots$，第一个非0位前一直到小数点前1位，总共有k个0，就要左移k位（逐次移位，共k次），且每次移位时将阶码-1.
	2. 需要右规的形式：$1b.bbbb\dots$，因为做加减时两数最多小数点左一位为1，得到的结果绝对值一定小于4，因此若小数点左第2位为1，则需要右规1位，否则不需要右规。
4. 尾数**舍入**：四种舍入方式
	1. 就近舍入：如果尾数并非正好在向0舍入和向1舍入的中间，则LSB（最低有效位）向较近的那个方向舍入；否则在正中间的话，IEEE754规定，LSB（最低有效位）为1，则在LSB位+1并舍去后面，否则LSB为0则直接截断后面（也就是无论如何强制成为偶数）。
	2. 向$+\infty$舍入：总是取大于该数的最近可表示数
	3. 向$-\infty$舍入：总是取小于该数的最近可表示数
	4. 向0舍入（直接截断超出精度的部分，最简单）
5. **溢出**判断：==**主要通过阶码而非尾数判断溢出**==
	1. 规格化的过程中可能发生溢出：左规可能发生下溢，如果当前阶码全0，则已经下溢；若$E=0\dots 0001$而左规还没有结束，就可以判定将发生下溢。右规可能发生上溢，因为右规最多右移1位，若当前阶码全1，则已经上溢；否则若$E=1\dots 110$且需要右规，则将发生上溢。