ISA，Instruction Set Architecture, 指令集体系结构，指令系统。
# 指令集概念/常识


# 指令系统设计
==**设计的基本原则：**==
- 指令尽量短（节省程序存储空间）
- **操作码位数**足够（指令系统应向后兼容，预留可能添加的指令类型）
- 指令长度是字节的整数倍（便于访问、存取，**便于计算地址**）
- 合理选取**地址字段的个数**：可能影响指令长度和规整性，影响执行效率
- 指令应尽量规整：**指令长度**定长/变长？**操作码位数**是否固定？**地址码**格式是否一致？字段位置划分是否一致？

## 操作类型
算术运算（四则、移位等）、逻辑运算（按位逻辑运算、移位等）、传送（寄存器间、寄存器与主存间）、**顺序控制**（条件转移BRANCH、无条件转移JMP、调用CALL、返回RET等）、系统控制（进入特殊处理程序或控制硬件运行等特权指令）、I/O操作（需要控制外部设备，通常为特权指令）
## 操作数和寻址方式
可能的操作数类型：无符号整数（多用于表示指针/地址），有符号整数，浮点数（多用IEEE754），位和位串，字符和字符串，逻辑值等。


- 注意有效地址与形式地址的含义：形式地址是指令字面上给出的地址，有效地址是实际存储所需操作数的主/虚存地址。
- 指令必须显式或隐式包含信息：**==操作码、源操作数等的地址、结果的存放地址、下条指令地址。==** 顺序执行时$PC$自增即得下条指令地址；如果需要跳转则通常需要相对寻址，与操作数的寻址类似。

寻址方式：给出的立即数解读为**操作数本身/内存地址/寄存器编号等**。
- 立即寻址：$X=addr$（立即数就是操作数）
- 直接寻址：$X=M[addr]$
- 间接寻址：$X=M[M[addr]]$（可能还有更多次间接寻址）
- 寄存器（直接）寻址：$X=R[rx]$
- 寄存器间接寻址：$X=M[R[rx]]$
- 偏移寻址：有三种主要方式
	- 变址寻址：偏移量隐含在变址寄存器中，指令中显式给出基准地址A，$EA=A+(I)$。**若多于一个寄存器可以作为变址寄存器，要显式指出使用哪个变址寄存器**。==常用于循环语句从数组头部开始迭代其各个元素。==，==偏移量是相对**首地址**的正偏移量，为无符号整数==。
	- 基址寻址：与变址寻址相反，指令给出**偏移量**$A$（==一般有符号==），基准地址$B$隐函在基址寄存器中（若不止一个通用寄存器可作为基址寄存器，也要显示指出使用哪个基址寄存器。）$EA=(B)+A$
	- 相对寻址：**基准地址由PC给出**，指令给出偏移量$A$（==有符号==），可以**访问相对当前指令前后一定范围内的指令或数据，实现相对跳转（如函数调用、条件转移、无条件转移等）**。$EA=(PC)+A$
- 其他：如栈寻址（默认取出栈顶一个或两个操作数，操作结果重新压栈）

优缺点：直接型寻址通常访存次数少、较快，但访问的地址范围有限；间接型较慢，但访问地址范围较大。偏移寻址更灵活也更复杂。

p.s. PC寄存器名为指令计数器，实际上存储的是下一条指令的地址，在非顺序执行时并不是简单的自增。

## 指令字和操作码长度/编码方式

==指令字与操作码是否定长==
执行效率与占用空间的权衡：效率更重要，则多用定长指令字、定长操作码；空间更重要，则多用变长指令字、边长操作码。定长操作码不一定定长指令字（还受到地址字段位数个数等影响），变长操作码一般变长指令字。
- 变长指令字、定长操作码：如IBM370，读取操作码后就知道属于哪种长度的指令（指令有几种固定长度）
- 变长指令字、变长操作码：如PDP-11，**操作码采用扩展码方法**——要求**操作码有几种不同的长度类型**，且**短操作码不为长操作码的前缀**。宜用等长扩展式，读取一部分操作码之后就知道操作码是已经读完还是还没读完。


## 指令设计风格
- 按**操作数位置的指定方式**，风格划分：
	- 累加器型：操作结果和一个操作数总是隐含为累加器。很早期机器采用
	- 栈型：如JVM（Java虚拟机），规定操作数总来自栈顶（类似栈寻址方式），不需要显式指明，因此指令大多为零地址/一地址，指令短，但是不灵活，可能需要更多条，实际机器一般不采用。
	>累加器型、栈型看似指令简单，但因为隐含固定存储位置而变得不灵活，需要更多的指令条数。

	- **通用寄存器型**指令系统：**使用大量通用寄存器存储临时数据**。操作数为立即寻址I（立即数）/寄存器寻址R/存储器寻址S，两个操作数可以有不同寻址方式，较灵活。
	- **Load/Store型**：也是通用寄存器型指令系统，在此基础上**只允许Load/Store访问存储器，其他都在寄存器进行**（大部分指令规整、等长，执行比较高效）。
- 按指令格式复杂度划分：
	- CISC
	- RISC

- CISC：Complex Instruction Set Computer：复杂指令集计算机
- RISC：Reduced Instruction Set Computer：精简指令集计算机
>CISC的英文全称为“Complex Instruction Set Computer”，即“复杂指令系统计算机”，从计算机诞生以来，人们一直沿用CISC指令集方式。早期的桌面软件是按CISC设计的，并一直沿续到现在。目前，桌面计算机流行的x86体系结构即使用CISC。微处理器(CPU)厂商一直在走CISC的发展道路，包括Intel、AMD，还有其他一些现在已经更名的厂商，如TI(德州仪器)、IBM以及VIA(威盛)等。在CISC微处理器中，程序的各条指令是按顺序串行执行的，每条指令中的各个操作也是按顺序串行执行的。顺序执行的优点是控制简单，但计算机各部分的利用率不高，执行速度慢。CISC架构的服务器主要以IA-32架构(Intel Architecture，英特尔架构)为主，而且多数为中低档服务器所采用。
　　RISC的英文全称为“Reduced Instruction Set Computer”，即“精简指令集计算机”，是一种执行较少类型计算机指令的微处理器，起源于80年代的MIPS主机(即RISC机)，RISC机中采用的微处理器统称RISC处理器。这样一来，它能够以更快的速度执行操作(每秒执行更多百万条指令，即MIPS)。因为计算机执行每个指令类型都需要额外的晶体管和电路元件，计算机指令集越大就会使微处理器更复杂，执行操作也会更慢。
————————————————
原文链接：https://blog.csdn.net/jukaiit/article/details/103710732


- x86：Intel开发的一种CISC型的指令系统。注重向前兼容（保证指令集能在早期结构的计算机上运行）
	- 指令较复杂，有专门的寻址方式位。
- IA-32：全称Intel-Architecture 32，CISC。
- MIPS：一种RISC型的指令系统（早期的RISC型指令系统）。
	- 没有专门的寻址方式位，看到**操作码**就已经确定哪些是地址字段、分别采用什么寻址方式。

RISC的特点：**指令数目少**、**格式规整**（定长指令字、定长操作码，指令各部分位置较固定）、**Load/Store型、大量使用通用寄存器**（用RR即两个操作数均为寄存器内容的方式工作，只有Load/Store访问主存）、指令周期短（因为规整所以可以设计用**流水线**方式执行），更加便于编译优化（也是因为规整）。


## 异常和中断
异常和中断指CPU当前的工作需要被停止或中止。
- 内部异常：
	- 硬件性异常，如断电、硬件线路故障
	- 程序性中断，如越界访问、溢出、除以0等（指令的执行发生非法情况，是系统能检测并识别出的异常）
- 外部中断：外部设备向CPU请求中断工作，如打印机缺纸等

异常和中断的处理：从用户模式进入OS模式（用户态->内核态），CPU在内核态完成应对之后回到用户态，重新执行出现异常的指令，或者跳过执行下一条，或者直接终止程序。


# 指令系统实例：RISC-V
- 开源、公益
- 采用模块化设计原则，有**稳定的基础指令集**和**灵活的扩展指令集**
	- 基础：RV32I（32位整数指令集，32位是指**指令字为定长32位**），固定、完备，永远不发生变化
	- 标准扩展指令集包括RV32M（整数乘除法）,RV32F（单精度浮点）,RV32D（双精度浮点）,RV32A（原子操作扩展）
	  RV32M+RV32F+RV32D=RV32MFD
	  RV32I+RV32MFD=RV32IMFD
	  RV32I+RV32MFD+RV32A=RV32IMAFD=RV32G（**通用32位指令集**）
	- RV32C：RV23G的**压缩版**，指令压缩到16位
	  压缩指令集的作用是减小程序存储空间，执行时需要先转为对应的RV32I程序，表达能力下降，则程序可能会变长，牺牲少量时间来换空间
	- RV64G与此同理（64位指令集），也有压缩到16位指令的版本RV64C
	- RV32V, RV64V：**向量计算指令集**。
	- RV32E：是RV32I的子集，专门用于**嵌入式场景**（小面积、低功耗）。

伪指令：是一些并不对应真正的机器指令，而等效于一或多条汇编指令/机器指令的操作。伪指令的设计目的是增强代码的可读性。汇编程序将其翻译为等效的机器指令。

## RTL语言
Register Transfer Level / 寄存器传送级语言：描述指令的功能。
```
R[r], M[addr], M[R[r]], PC, M[PC], 
SEXT[imm], # 符号扩展 
ZEXT[imm], # 零扩展
← # 将右边的数据传送到左边
```

## RV32I（基础整数指令集）
[一文看懂RISC-V的RV32I指令集_risc-v b 和 j 格式的分支和-CSDN博客](https://blog.csdn.net/limanjihe/article/details/122395354)

汇编指令中立即数的写法是：**将n位立即数当成n位补码，写出它对应的十进制真值**。

关于[[RV32I的助记符格式]]：开头的a(add), l(load), s(set/shift), j(jump), b(branch)等多用于描述操作类型。结尾的u(upper/unsigned), i(immediate number)用于描述该操作是否是对高位操作、是否提供立即数等。
常见指令的RTL语言描述：
```

# 整数运算类
lui rd, imm20 # R[rd] <- imm20 | 000H
auipc rd, imm20 # R[rd] <- PC+(imm20|000H)
add rd, rs1, rs2 # R[rd] <- R[rs1]+R[rs2] # 这是最简单的R型指令格式
addi rd, rs1, imm12 # R[rd] <- R[rs1]+SEXT[imm12]
sll rd, rs1, rs2 # R[rd] <- R[rs1]<<R[rs2] # Shift Left Logical（与Arithmetic无区别）
slli rd, rs1, shamt # R[rd] <- R[rs1]<<SEXT[imm12]
slt rd, rs1, rs2 # R[rd] <- 1 if R[rs1]<R[rs2] else 0（有符号数比较）
slti rd, rs1, imm12
sltu rd, rs1, rs2
sltiu rd, rs1, imm12

# 顺序控制类
bne rs1, rs2, label # 若rs1!=rs2则跳转到label标志的指令。编译时label会变成一个12位立即数imm[12:1]，将它乘2就是真正的PC增量（RISC-V标准下最小编址单元是字节）
jal rd, imm12 # Jump and Link，Jump是指PC <- PC+SEXT[imm12], Link是指R[rd] <- PC+4，Link的作用是指明过程调用返回时接下去执行的指令位置，如果设rd=x0则因rd是只读零，不会做任何修改，实现的就不是过程调用而是无条件转移。
jalr rd, rs1, imm12 # PC <- R[rs1]+SEXT[imm12], R[rd] <- PC+4 # 提供基于R[rs1]而非PC的基准地址
# 如：jalr x0, x1, 0可以实现过程调用的返回，其中x1记录的是过程调用返回的位置

```

